"""Core Pydantic models used across the algotrader system."""

from __future__ import annotations

from datetime import datetime, date
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


# ── Enums ────────────────────────────────────────────────────────────────────


class OrderSide(str, Enum):
    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"


class OrderStatus(str, Enum):
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


class TimeInForce(str, Enum):
    DAY = "day"
    GTC = "gtc"
    IOC = "ioc"
    FOK = "fok"
    OPG = "opg"
    CLS = "cls"


class RegimeType(str, Enum):
    TRENDING_UP = "trending_up"
    TRENDING_DOWN = "trending_down"
    RANGING = "ranging"
    HIGH_VOL = "high_vol"
    LOW_VOL = "low_vol"
    EVENT_DAY = "event_day"


class SignalDirection(str, Enum):
    LONG = "long"
    SHORT = "short"
    CLOSE = "close"


# ── Market Data Models ───────────────────────────────────────────────────────


class Bar(BaseModel):
    """OHLCV bar."""

    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    vwap: float | None = None
    trade_count: int | None = None


class Quote(BaseModel):
    """Bid/ask quote."""

    symbol: str
    timestamp: datetime
    bid_price: float
    bid_size: float
    ask_price: float
    ask_size: float

    @property
    def mid_price(self) -> float:
        return (self.bid_price + self.ask_price) / 2

    @property
    def spread(self) -> float:
        return self.ask_price - self.bid_price

    @property
    def spread_pct(self) -> float:
        if self.mid_price == 0:
            return 0.0
        return self.spread / self.mid_price

    def is_valid(self) -> bool:
        """Check bid/ask > 0 before placing limit orders."""
        return self.bid_price > 0 and self.ask_price > 0


class Snapshot(BaseModel):
    """Current snapshot of a symbol: latest bar, quote, and trade info."""

    symbol: str
    latest_trade_price: float | None = None
    latest_trade_timestamp: datetime | None = None
    latest_quote: Quote | None = None
    minute_bar: Bar | None = None
    daily_bar: Bar | None = None
    prev_daily_bar: Bar | None = None


class MarketClock(BaseModel):
    """Market clock info."""

    timestamp: datetime
    is_open: bool
    next_open: datetime
    next_close: datetime


class NewsItem(BaseModel):
    """A news article."""

    id: str
    headline: str
    summary: str = ""
    source: str = ""
    url: str = ""
    symbols: list[str] = Field(default_factory=list)
    timestamp: datetime | None = None
    sentiment_score: float | None = None


# ── Order & Position Models ──────────────────────────────────────────────────


class Order(BaseModel):
    """An order (submitted or filled)."""

    id: str = ""
    client_order_id: str = ""
    symbol: str
    side: OrderSide
    order_type: OrderType = OrderType.MARKET
    time_in_force: TimeInForce = TimeInForce.DAY
    qty: float = 0.0
    limit_price: float | None = None
    stop_price: float | None = None
    status: OrderStatus = OrderStatus.PENDING
    filled_qty: float = 0.0
    filled_avg_price: float | None = None
    submitted_at: datetime | None = None
    filled_at: datetime | None = None
    strategy_name: str = ""
    metadata: dict[str, Any] = Field(default_factory=dict)


class Position(BaseModel):
    """A held position."""

    symbol: str
    qty: float
    side: OrderSide
    avg_entry_price: float
    current_price: float = 0.0
    market_value: float = 0.0
    unrealized_pnl: float = 0.0
    unrealized_pnl_pct: float = 0.0
    strategy_name: str = ""


class AccountInfo(BaseModel):
    """Broker account summary."""

    equity: float
    cash: float
    buying_power: float
    portfolio_value: float
    day_trade_count: int = 0
    pattern_day_trader: bool = False


# ── Strategy & Signal Models ─────────────────────────────────────────────────


class Signal(BaseModel):
    """A trading signal generated by a strategy."""

    strategy_name: str
    symbol: str
    direction: SignalDirection
    conviction: float = 0.5  # 0.0 to 1.0 confidence
    target_price: float | None = None
    stop_price: float | None = None
    reason: str = ""
    metadata: dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime | None = None


class TradeRecord(BaseModel):
    """Complete record of a trade for the journal."""

    id: str = ""
    strategy_name: str
    symbol: str
    side: OrderSide
    qty: float
    entry_price: float
    exit_price: float | None = None
    entry_time: datetime | None = None
    exit_time: datetime | None = None
    realized_pnl: float = 0.0
    unrealized_pnl: float = 0.0
    conviction: float = 1.0
    regime: RegimeType | None = None
    entry_reason: str = ""
    exit_reason: str = ""
    metadata: dict[str, Any] = Field(default_factory=dict)


class MarketRegime(BaseModel):
    """Current market regime classification."""

    regime_type: RegimeType
    vix_level: float | None = None
    spy_trend: float | None = None  # SMA slope
    volatility_percentile: float | None = None
    confidence: float = 1.0
    timestamp: datetime | None = None


# ── Strategy Status ──────────────────────────────────────────────────────────


class StrategyStatus(BaseModel):
    """Status report from a strategy."""

    name: str
    enabled: bool = True
    active_positions: int = 0
    capital_reserved: float = 0.0
    capital_used: float = 0.0
    daily_pnl: float = 0.0
    daily_trades: int = 0
    daily_wins: int = 0
    daily_losses: int = 0
    last_cycle_time: datetime | None = None
    metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def win_rate(self) -> float:
        total = self.daily_wins + self.daily_losses
        if total == 0:
            return 0.0
        return self.daily_wins / total
